{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-mvc-i18n zend-mvc-i18n provides integration between: zend-i18n zend-mvc zend-router and replaces the i18n functionality found in the v2 releases of the latter two components. File issues at https://github.com/zendframework/zend-mvc-i18n/issues Documentation is at https://docs.zendframework.com/zend-mvc-i18n/ Installation $ composer require zendframework/zend-mvc-i18n Assuming you are using the component installer , doing so will enable the component in your application, allowing you to immediately start developing console applications via your MVC. If you are not, please read the introduction for details on how to register the functionality with your application. For use with zend-mvc v3 and up While this component has an initial stable release, please do not use it with zend-mvc releases prior to v3, as it is not compatible. Migrating from zend-mvc v2 i18n features to zend-mvc-i18n Please see the migration guide for details on how to migrate your existing zend-mvc console functionality to the features exposed by this component.","title":"Home"},{"location":"#zend-mvc-i18n","text":"zend-mvc-i18n provides integration between: zend-i18n zend-mvc zend-router and replaces the i18n functionality found in the v2 releases of the latter two components. File issues at https://github.com/zendframework/zend-mvc-i18n/issues Documentation is at https://docs.zendframework.com/zend-mvc-i18n/","title":"zend-mvc-i18n"},{"location":"#installation","text":"$ composer require zendframework/zend-mvc-i18n Assuming you are using the component installer , doing so will enable the component in your application, allowing you to immediately start developing console applications via your MVC. If you are not, please read the introduction for details on how to register the functionality with your application.","title":"Installation"},{"location":"#for-use-with-zend-mvc-v3-and-up","text":"While this component has an initial stable release, please do not use it with zend-mvc releases prior to v3, as it is not compatible.","title":"For use with zend-mvc v3 and up"},{"location":"#migrating-from-zend-mvc-v2-i18n-features-to-zend-mvc-i18n","text":"Please see the migration guide for details on how to migrate your existing zend-mvc console functionality to the features exposed by this component.","title":"Migrating from zend-mvc v2 i18n features to zend-mvc-i18n"},{"location":"intro/","text":"Introduction Zend Framework 2 offered functionality for integrating internationalization capabilities provided by zend-i18n into MVC applications. This support includes: registration of an MvcTranslator service by default. a DummyTranslator , for use when ext/intl is unavailable, or configuration dictates that translations are disabled. an MvcTranslator , which implements both Zend\\I18n\\Translator\\TranslatorInterface and Zend\\Validator\\TranslatorInterface , which decorates a Zend\\I18n\\Translator\\TranslatorInterface instance. a TranslatorAwareTreeRouteStack , for enabling internationalized routing segments. Since this functionality is entirely opt-in, we have decided that for version 3 of zend-mvc, we will offer it as a standalone package, to install when required for your applications. Additionally, because it bridges multiple TranslatorInterface implementations, and provides i18n-capable routing, it can be useful with non-zend-mvc applications such as zend-expressive . Installation Basic installation is via composer: $ composer require zendframework/zend-mvc-i18n Assuming you are using the component installer , doing so will automatically enable the component in your application. If you are not using the component installer, you will need to add the entry: 'Zend\\Mvc\\I18n' to your list of active modules. This is usually provided in one of the following files: config/application.config.php (vanilla ZF skeleton application) config/modules.config.php (Apigility application) Manually enabling with zend-expressive If you are not using the component-installer with zend-expressive, you will need to add the entry: $$$$FENCED_CODE_BLOCK_5dbff22504e5b4.21772294 to your config/config.php class, assuming you are already using zend-config-aggregator . If you are not, add a new global config/autoload/ file with the following contents: $$$$FENCED_CODE_BLOCK_5dbff22504e979.01566679 Migration In order to separate the i18n integration features from zend-mvc, we made a few minor changes. While most of these are under-the-hood implementation details, please read the migration guide to verify your application will continue to work.","title":"Introduction"},{"location":"intro/#introduction","text":"Zend Framework 2 offered functionality for integrating internationalization capabilities provided by zend-i18n into MVC applications. This support includes: registration of an MvcTranslator service by default. a DummyTranslator , for use when ext/intl is unavailable, or configuration dictates that translations are disabled. an MvcTranslator , which implements both Zend\\I18n\\Translator\\TranslatorInterface and Zend\\Validator\\TranslatorInterface , which decorates a Zend\\I18n\\Translator\\TranslatorInterface instance. a TranslatorAwareTreeRouteStack , for enabling internationalized routing segments. Since this functionality is entirely opt-in, we have decided that for version 3 of zend-mvc, we will offer it as a standalone package, to install when required for your applications. Additionally, because it bridges multiple TranslatorInterface implementations, and provides i18n-capable routing, it can be useful with non-zend-mvc applications such as zend-expressive .","title":"Introduction"},{"location":"intro/#installation","text":"Basic installation is via composer: $ composer require zendframework/zend-mvc-i18n Assuming you are using the component installer , doing so will automatically enable the component in your application. If you are not using the component installer, you will need to add the entry: 'Zend\\Mvc\\I18n' to your list of active modules. This is usually provided in one of the following files: config/application.config.php (vanilla ZF skeleton application) config/modules.config.php (Apigility application)","title":"Installation"},{"location":"intro/#migration","text":"In order to separate the i18n integration features from zend-mvc, we made a few minor changes. While most of these are under-the-hood implementation details, please read the migration guide to verify your application will continue to work.","title":"Migration"},{"location":"routing/","text":"Routing zend-router provides routing capabilities for zend-mvc . In version 2, these capabilities also included an opt-in feature of translatable route segments. Zend\\Router\\Http\\Segment has built-in facilities for translatable route segments, but this functionality is disabled by default. To enable it, a translator must be present in the options provided when matching; such options are typically passed by the route stack invoking the segment. zend-mvc-i18n provides Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack to do exactly that. If it is injected with a translator, it will pass the translator on to each segment when invoking match() . Enabling TranslatorAwareTreeRouteStack To enable the TranslatorAwareTreeRouteStack in your application, you will need to add configuration that tells zend-mvc to use it instead of the default router. Additionally, you may want to indicate the translation locale and/or text domain to use for translatable route segments. The following is a configuration example that could be specified in a module or at the application level: use Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack; return [ 'router' => [ 'router_class' => TranslatorAwareTreeRouteStack::class, 'translator_text_domain' => 'routing', ], ]; The above would configure and return a TranslatorAwareTreeRouteStack instance when the router is requested. The instance would be configured to use the routing text domain, and injected with either the MvcTranslator or Zend\\I18n\\Translator\\TranslatorInterface service (whichever is present, with the former having precedence). The translator_text_domain , when not present, defaults to default . Translatable route segments As a refresher, segment routes allow you to define a combination of literal characters and placeholders; placeholders are denoted by :name notation within the definition. To create a translatable segment, you use an alternate notation, {translation-key} . When matching, the translator uses its locale and the text domain configured to translate translation keys in the route definition prior to attempting a match. As an example, consider the following route definition: /{shopping_cart}/{products}/:productId The above defines two translatable segments, shopping_cart and products . When attempting to match, these keys are passed to the translator. If, for example, the locale evaluates to de-DE , these might become einkaufswagen and 'produkte`, respectively, evaluating to: /einkaufswagen/produkte/:productId This will then be what the router attempts to match against.","title":"Routing"},{"location":"routing/#routing","text":"zend-router provides routing capabilities for zend-mvc . In version 2, these capabilities also included an opt-in feature of translatable route segments. Zend\\Router\\Http\\Segment has built-in facilities for translatable route segments, but this functionality is disabled by default. To enable it, a translator must be present in the options provided when matching; such options are typically passed by the route stack invoking the segment. zend-mvc-i18n provides Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack to do exactly that. If it is injected with a translator, it will pass the translator on to each segment when invoking match() .","title":"Routing"},{"location":"routing/#enabling-translatorawaretreeroutestack","text":"To enable the TranslatorAwareTreeRouteStack in your application, you will need to add configuration that tells zend-mvc to use it instead of the default router. Additionally, you may want to indicate the translation locale and/or text domain to use for translatable route segments. The following is a configuration example that could be specified in a module or at the application level: use Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack; return [ 'router' => [ 'router_class' => TranslatorAwareTreeRouteStack::class, 'translator_text_domain' => 'routing', ], ]; The above would configure and return a TranslatorAwareTreeRouteStack instance when the router is requested. The instance would be configured to use the routing text domain, and injected with either the MvcTranslator or Zend\\I18n\\Translator\\TranslatorInterface service (whichever is present, with the former having precedence). The translator_text_domain , when not present, defaults to default .","title":"Enabling TranslatorAwareTreeRouteStack"},{"location":"routing/#translatable-route-segments","text":"As a refresher, segment routes allow you to define a combination of literal characters and placeholders; placeholders are denoted by :name notation within the definition. To create a translatable segment, you use an alternate notation, {translation-key} . When matching, the translator uses its locale and the text domain configured to translate translation keys in the route definition prior to attempting a match. As an example, consider the following route definition: /{shopping_cart}/{products}/:productId The above defines two translatable segments, shopping_cart and products . When attempting to match, these keys are passed to the translator. If, for example, the locale evaluates to de-DE , these might become einkaufswagen and 'produkte`, respectively, evaluating to: /einkaufswagen/produkte/:productId This will then be what the router attempts to match against.","title":"Translatable route segments"},{"location":"services/","text":"Services Defined zend-mvc-i18n defines the following services and related factories. Translator Zend\\Mvc\\I18n\\Translator implements each of Zend\\I18n\\Translator\\TranslatorInterface (from zend-i18n) and implements Zend\\Validator\\TranslatorInterface (from zend-validator), by decorating an Zend\\I18n\\Translator\\TranslatorInterface instance (typically a Zend\\I18n\\Translator\\Translator instance). It exists to allow bridging multiple translation interfaces, allowing it to be used in multiple contexts. DummyTranslator Zend\\Mvc\\I18n\\DummyTranslator is an implementation of Zend\\I18n\\Translator\\TranslatorInterface that essentially returns the arguments provided to it unchanged. As an example, calling: $translator->translate($message); will return $message , and $translator->translatePlural($singular, $plural, $number); will return $singular when $number is 1 , and $plural otherwise. MvcTranslator and TranslatorFactory The component defines the MvcTranslator service, which is aliased to the Zend\\Mvc\\I18n\\Translator class, and uses Zend\\Mvc\\I18n\\TranslatorFactory to create and return the instance. The point of the service is to ensure that a Zend\\Mvc\\I18n\\Translator instance is returned, which enables usage across multiple contexts (see the Translator section , above). As such, you should typically use the MvcTranslator service when injecting your own classes with a translator instance: function ($container) { return new YourServiceClass($container->get('MvcTranslator')); } The TranslatorFactory will do the following: If a Zend\\I18n\\Translator\\TranslatorInterface service is registered, it will be retrieved and decorated with a Zend\\Mvc\\I18n\\Translator instance. If the \"config\" service is defined in the container, has a \"translator\" key, but the value of that key is boolean false, it returns a Zend\\Mvc\\I18n\\Translator instance wrapping a DummyTranslator instance. If the \"config\" service is defined in the container, has a \"translator\" key, and value is an array or Traversable set of configuration, it passes that to Zend\\I18n\\Translator\\Translator::factory() to create and return an instance. That instance is then decorated with a Zend\\Mvc\\I18n\\Translator . HttpRouterDelegatorFactory The component registers a delegator factory on each of the HttpRouter and Zend\\Router\\Http\\TreeRouteStack services. The delegator factory checks to see if the instance created is a Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack , and, if so: if the MvcTranslator service is present, it will inject it as the translator before returning it. if the Zend\\I18n\\Translator\\TranslatorInterface service is present, it will inject it as the translator before returning it. otherwise, it disables translation in the returned instance.","title":"Default Services"},{"location":"services/#services-defined","text":"zend-mvc-i18n defines the following services and related factories.","title":"Services Defined"},{"location":"services/#translator","text":"Zend\\Mvc\\I18n\\Translator implements each of Zend\\I18n\\Translator\\TranslatorInterface (from zend-i18n) and implements Zend\\Validator\\TranslatorInterface (from zend-validator), by decorating an Zend\\I18n\\Translator\\TranslatorInterface instance (typically a Zend\\I18n\\Translator\\Translator instance). It exists to allow bridging multiple translation interfaces, allowing it to be used in multiple contexts.","title":"Translator"},{"location":"services/#dummytranslator","text":"Zend\\Mvc\\I18n\\DummyTranslator is an implementation of Zend\\I18n\\Translator\\TranslatorInterface that essentially returns the arguments provided to it unchanged. As an example, calling: $translator->translate($message); will return $message , and $translator->translatePlural($singular, $plural, $number); will return $singular when $number is 1 , and $plural otherwise.","title":"DummyTranslator"},{"location":"services/#mvctranslator-and-translatorfactory","text":"The component defines the MvcTranslator service, which is aliased to the Zend\\Mvc\\I18n\\Translator class, and uses Zend\\Mvc\\I18n\\TranslatorFactory to create and return the instance. The point of the service is to ensure that a Zend\\Mvc\\I18n\\Translator instance is returned, which enables usage across multiple contexts (see the Translator section , above). As such, you should typically use the MvcTranslator service when injecting your own classes with a translator instance: function ($container) { return new YourServiceClass($container->get('MvcTranslator')); } The TranslatorFactory will do the following: If a Zend\\I18n\\Translator\\TranslatorInterface service is registered, it will be retrieved and decorated with a Zend\\Mvc\\I18n\\Translator instance. If the \"config\" service is defined in the container, has a \"translator\" key, but the value of that key is boolean false, it returns a Zend\\Mvc\\I18n\\Translator instance wrapping a DummyTranslator instance. If the \"config\" service is defined in the container, has a \"translator\" key, and value is an array or Traversable set of configuration, it passes that to Zend\\I18n\\Translator\\Translator::factory() to create and return an instance. That instance is then decorated with a Zend\\Mvc\\I18n\\Translator .","title":"MvcTranslator and TranslatorFactory"},{"location":"services/#httprouterdelegatorfactory","text":"The component registers a delegator factory on each of the HttpRouter and Zend\\Router\\Http\\TreeRouteStack services. The delegator factory checks to see if the instance created is a Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack , and, if so: if the MvcTranslator service is present, it will inject it as the translator before returning it. if the Zend\\I18n\\Translator\\TranslatorInterface service is present, it will inject it as the translator before returning it. otherwise, it disables translation in the returned instance.","title":"HttpRouterDelegatorFactory"},{"location":"migration/v2-to-v3/","text":"Migration: zend-mvc v2 to zend-mvc-i18n zend-mvc-i18n ports all i18n integration functionality from the zend-mvc v2 release to a single component. As such, a number of classes were renamed that could potentially impact end-users. TranslatorAwareTreeRouteStack Zend\\Mvc\\Router\\Http\\TranslatorAwareTreeRouteStack was renamed to Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack . It functions exactly as the original, however, including accepting the same configuration. TranslatorServiceFactory Zend\\Mvc\\Service\\TranslatorServiceFactory was renamed to Zend\\Mvc\\I18n\\TranslatorFactory . Behavior remains the same. Exceptions thrown by the MVC translator In v2 releases, Zend\\Mvc\\I18n\\Translator would throw exceptions from the Zend\\Mvc\\Exception namespace. It now throws exceptions from the new Zend\\Mvc\\I18n\\Exception namespace.","title":"Version 2 to Version 3"},{"location":"migration/v2-to-v3/#migration-zend-mvc-v2-to-zend-mvc-i18n","text":"zend-mvc-i18n ports all i18n integration functionality from the zend-mvc v2 release to a single component. As such, a number of classes were renamed that could potentially impact end-users.","title":"Migration: zend-mvc v2 to zend-mvc-i18n"},{"location":"migration/v2-to-v3/#translatorawaretreeroutestack","text":"Zend\\Mvc\\Router\\Http\\TranslatorAwareTreeRouteStack was renamed to Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack . It functions exactly as the original, however, including accepting the same configuration.","title":"TranslatorAwareTreeRouteStack"},{"location":"migration/v2-to-v3/#translatorservicefactory","text":"Zend\\Mvc\\Service\\TranslatorServiceFactory was renamed to Zend\\Mvc\\I18n\\TranslatorFactory . Behavior remains the same.","title":"TranslatorServiceFactory"},{"location":"migration/v2-to-v3/#exceptions-thrown-by-the-mvc-translator","text":"In v2 releases, Zend\\Mvc\\I18n\\Translator would throw exceptions from the Zend\\Mvc\\Exception namespace. It now throws exceptions from the new Zend\\Mvc\\I18n\\Exception namespace.","title":"Exceptions thrown by the MVC translator"}]}